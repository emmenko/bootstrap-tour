// Generated by CoffeeScript 1.6.3
(function() {
  describe("Bootstrap Tour", function() {
    afterEach(function() {
      var popover;
      this.tour.setState("current_step", null);
      this.tour.setState("end", null);
      popover = $(".popover");
      if (popover.length > 0) {
        popover.remove();
      }
      return $.each(this.tour._steps, function(i, s) {
        if ((s.element != null) && (s.element.popover != null)) {
          return s.element.popover("hide").removeData("popover");
        }
      });
    });
    it("should set the tour options", function() {
      this.tour = new Tour({
        name: "test",
        afterSetState: function() {
          return true;
        },
        afterGetState: function() {
          return true;
        }
      });
      expect(this.tour._options.name, "options.name is set").to.equal("test");
      assert.ok(this.tour._options.afterGetState, "options.afterGetState is set");
      return assert.ok(this.tour._options.afterSetState, "options.afterSetState is set");
    });
    it("should have default name of 'tour'", function() {
      this.tour = new Tour();
      return expect(this.tour._options.name, "tour default name is 'tour'").to.equal("tour");
    });
    it("should accept an array of steps and set the current step", function() {
      this.tour = new Tour();
      assert.deepEqual(this.tour._steps, [], "tour accepts an array of steps");
      return assert.strictEqual(this.tour._current, 0, "tour initializes current step");
    });
    it("'setState' should save state cookie", function() {
      this.tour = new Tour();
      this.tour.setState("save", "yes");
      assert.strictEqual($.cookie("tour_save"), "yes", "tour saves state cookie");
      return $.removeCookie("tour_save");
    });
    it("'getState' should get state cookie", function() {
      this.tour = new Tour();
      this.tour.setState("get", "yes");
      assert.strictEqual(this.tour.getState("get"), "yes", "tour gets state cookie");
      return $.removeCookie("tour_get");
    });
    it("'setState' should save state localStorage items", function() {
      this.tour = new Tour({
        useLocalStorage: true
      });
      this.tour.setState("test", "yes");
      return assert.strictEqual(window.localStorage.getItem("tour_test"), "yes", "tour save state localStorage items");
    });
    it("'getState' should get state localStorage items", function() {
      this.tour = new Tour({
        useLocalStorage: true
      });
      this.tour.setState("test", "yes");
      assert.strictEqual(this.tour.getState("test"), "yes", "tour saves state localStorage items");
      return window.localStorage.setItem("tour_test", null);
    });
    it("'addStep' should add a step", function() {
      var step;
      this.tour = new Tour();
      step = {
        element: $("<div>").appendTo("#container")
      };
      this.tour.addStep(step);
      return assert.deepEqual(this.tour._steps, [step], "tour adds the step");
    });
    it("'addSteps' should add multiple step", function() {
      var firstStep, secondStep;
      this.tour = new Tour();
      firstStep = {
        element: $("<div>").appendTo("#container")
      };
      secondStep = {
        element: $("<div>").appendTo("#container")
      };
      this.tour.addSteps([firstStep, secondStep]);
      return assert.deepEqual(this.tour._steps, [firstStep, secondStep], "tour adds multiple steps");
    });
    it("'step' should have an id", function() {
      var $element;
      this.tour = new Tour();
      $element = $("<div>").appendTo("#container");
      this.tour.addStep({
        element: $element
      });
      this.tour.start();
      return assert.strictEqual($element.data("popover").tip().attr("id"), "step-0", "tour runs onStart when the first step shown");
    });
    it("with onStart option should run the callback before showing the first step", function() {
      var tour_test;
      tour_test = 0;
      this.tour = new Tour({
        onStart: function() {
          return tour_test += 2;
        }
      });
      this.tour.addStep({
        element: $("<div>").appendTo("#container")
      });
      this.tour.start();
      return assert.strictEqual(tour_test, 2, "tour runs onStart when the first step shown");
    });
    it("with onEnd option should run the callback after hiding the last step", function() {
      var tour_test;
      tour_test = 0;
      this.tour = new Tour({
        onEnd: function() {
          return tour_test += 2;
        }
      });
      this.tour.addStep({
        element: $("<div>").appendTo("#container")
      });
      this.tour.start();
      this.tour.end();
      return assert.strictEqual(tour_test, 2, "tour runs onEnd when the last step hidden");
    });
    it("with onShow option should run the callback before showing the step", function() {
      var tour_test;
      tour_test = 0;
      this.tour = new Tour({
        onShow: function() {
          return tour_test += 2;
        }
      });
      this.tour.addStep({
        element: $("<div>").appendTo("#container")
      });
      this.tour.addStep({
        element: $("<div>").appendTo("#container")
      });
      this.tour.start();
      assert.strictEqual(tour_test, 2, "tour runs onShow when first step shown");
      this.tour.next();
      return assert.strictEqual(tour_test, 4, "tour runs onShow when next step shown");
    });
    it("with onShown option should run the callback after showing the step", function() {
      var tour_test;
      tour_test = 0;
      this.tour = new Tour({
        onShown: function() {
          return tour_test += 2;
        }
      });
      this.tour.addStep({
        element: $("<div>").appendTo("#container")
      });
      this.tour.addStep({
        element: $("<div>").appendTo("#container")
      });
      this.tour.start();
      return assert.strictEqual(tour_test, 2, "tour runs onShown after first step shown");
    });
    it("with onHide option should run the callback before hiding the step", function() {
      var tour_test;
      tour_test = 0;
      this.tour = new Tour({
        onHide: function() {
          return tour_test += 2;
        }
      });
      this.tour.addStep({
        element: $("<div>").appendTo("#container")
      });
      this.tour.addStep({
        element: $("<div>").appendTo("#container")
      });
      this.tour.start();
      this.tour.next();
      assert.strictEqual(tour_test, 2, "tour runs onHide when first step hidden");
      this.tour.hideStep(1);
      return assert.strictEqual(tour_test, 4, "tour runs onHide when next step hidden");
    });
    it("with onHidden option should run the callback after hiding the step", function() {
      var tour_test;
      tour_test = 0;
      this.tour = new Tour({
        onHidden: function() {
          return tour_test += 2;
        }
      });
      this.tour.addStep({
        element: $("<div>").appendTo("#container")
      });
      this.tour.addStep({
        element: $("<div>").appendTo("#container")
      });
      this.tour.start();
      this.tour.next();
      assert.strictEqual(tour_test, 2, "tour runs onHidden after first step hidden");
      this.tour.next();
      return assert.strictEqual(tour_test, 4, "tour runs onHidden after next step hidden");
    });
    it("'addStep' with onShow option should run the callback before showing the step", function() {
      var tour_test;
      tour_test = 0;
      this.tour = new Tour();
      this.tour.addStep({
        element: $("<div>").appendTo("#container")
      });
      this.tour.addStep({
        element: $("<div>").appendTo("#container"),
        onShow: function() {
          return tour_test = 2;
        }
      });
      this.tour.start();
      assert.strictEqual(tour_test, 0, "tour does not run onShow when step not shown");
      this.tour.next();
      return assert.strictEqual(tour_test, 2, "tour runs onShow when step shown");
    });
    it("'addStep' with onHide option should run the callback before hiding the step", function() {
      var tour_test;
      tour_test = 0;
      this.tour = new Tour();
      this.tour.addStep({
        element: $("<div>").appendTo("#container")
      });
      this.tour.addStep({
        element: $("<div>").appendTo("#container"),
        onHide: function() {
          return tour_test = 2;
        }
      });
      this.tour.start();
      this.tour.next();
      assert.strictEqual(tour_test, 0, "tour does not run onHide when step not hidden");
      this.tour.hideStep(1);
      return assert.strictEqual(tour_test, 2, "tour runs onHide when step hidden");
    });
    it("'getStep' should get a step", function() {
      var step;
      this.tour = new Tour();
      step = {
        element: $("<div>").appendTo("#container"),
        container: "body",
        path: "test",
        placement: "left",
        title: "Test",
        content: "Just a test",
        id: "step-0",
        prev: -1,
        next: 2,
        end: false,
        animation: false,
        backdrop: false,
        redirect: true,
        onShow: function(tour) {},
        onShown: function(tour) {},
        onHide: function(tour) {},
        onHidden: function(tour) {},
        onNext: function(tour) {},
        onPrev: function(tour) {},
        template: "<div class='popover tour'>      <div class='arrow'></div>      <h3 class='popover-title'></h3>      <div class='popover-content'></div>      </div>"
      };
      this.tour.addStep(step);
      return assert.deepEqual(this.tour.getStep(0), step, "tour gets a step");
    });
    it("'start' should start a tour", function() {
      this.tour = new Tour();
      this.tour.addStep({
        element: $("<div>").appendTo("#container")
      });
      this.tour.start();
      return assert.strictEqual($(".popover").length, 1, "tour starts");
    });
    it("'start' should not start a tour that ended", function() {
      this.tour = new Tour();
      this.tour.addStep({
        element: $("<div>").appendTo("#container")
      });
      this.tour.setState("end", "yes");
      this.tour.start();
      return assert.strictEqual($(".popover").length, 0, "previously ended tour don't start again");
    });
    it("'start'(true) should force starting a tour that ended", function() {
      this.tour = new Tour();
      this.tour.addStep({
        element: $("<div>").appendTo("#container")
      });
      this.tour.setState("end", "yes");
      this.tour.start(true);
      return assert.strictEqual($(".popover").length, 1, "previously ended tour starts again if forced to");
    });
    it("'next' should hide current step and show next step", function() {
      this.tour = new Tour();
      this.tour.addStep({
        element: $("<div>").appendTo("#container")
      });
      this.tour.addStep({
        element: $("<div>").appendTo("#container")
      });
      this.tour.start();
      this.tour.next();
      assert.strictEqual(this.tour.getStep(0).element.data("popover").tip().filter(":visible").length, 0, "tour hides current step");
      return assert.strictEqual(this.tour.getStep(1).element.data("popover").tip().filter(":visible").length, 1, "tour shows next step");
    });
    it("'end' should hide current step and set end state", function() {
      this.tour = new Tour();
      this.tour.addStep({
        element: $("<div>").appendTo("#container")
      });
      this.tour.start();
      this.tour.end();
      assert.strictEqual(this.tour.getStep(0).element.data("popover").tip().filter(":visible").length, 0, "tour hides current step");
      return assert.strictEqual(this.tour.getState("end"), "yes", "tour sets end state");
    });
    it("'ended' should return true is tour ended and false if not", function() {
      this.tour = new Tour();
      this.tour.addStep({
        element: $("<div>").appendTo("#container")
      });
      this.tour.start();
      assert.strictEqual(this.tour.ended(), false, "tour returns false if not ended");
      this.tour.end();
      return assert.strictEqual(this.tour.ended(), true, "tour returns true if ended");
    });
    it("'restart' should clear all states and start tour", function() {
      this.tour = new Tour();
      this.tour.addStep({
        element: $("<div>").appendTo("#container")
      });
      this.tour.addStep({
        element: $("<div>").appendTo("#container")
      });
      this.tour.start();
      this.tour.next();
      this.tour.end();
      this.tour.restart();
      assert.strictEqual(this.tour.getState("end"), null, "tour sets end state");
      assert.strictEqual(this.tour._current, 0, "tour sets first step");
      return assert.strictEqual($(".popover").length, 1, "tour starts");
    });
    it("'hideStep' should hide a step", function() {
      this.tour = new Tour();
      this.tour.addStep({
        element: $("<div>").appendTo("#container")
      });
      this.tour.start();
      this.tour.hideStep(0);
      return assert.strictEqual(this.tour.getStep(0).element.data("popover").tip().filter(":visible").length, 0, "tour hides step");
    });
    it("'showStep' should set a step and show it", function() {
      this.tour = new Tour();
      this.tour.addStep({
        element: $("<div>").appendTo("#container")
      });
      this.tour.addStep({
        element: $("<div>").appendTo("#container")
      });
      this.tour.showStep(1);
      assert.strictEqual(this.tour._current, 1, "tour sets step");
      assert.strictEqual($(".popover").length, 1, "tour shows one step");
      return assert.strictEqual(this.tour.getStep(1).element.data("popover").tip().filter(":visible").length, 1, "tour shows correct step");
    });
    it("'showStep' should not show anything when the step doesn't exist", function() {
      this.tour = new Tour();
      this.tour.addStep({
        element: $("<div>").appendTo("#container")
      });
      this.tour.addStep({
        element: $("<div>").appendTo("#container")
      });
      this.tour.showStep(2);
      return assert.strictEqual($(".popover").length, 0, "tour doesn't show any step");
    });
    it("'showStep' should skip step when no element is specified", function() {
      this.tour = new Tour();
      this.tour.addStep({});
      this.tour.addStep({
        element: $("<div>").appendTo("#container")
      });
      this.tour.showStep(1);
      return assert.strictEqual(this.tour.getStep(1).element.data("popover").tip().filter(":visible").length, 1, "tour skips step with no element");
    });
    it("'showStep' should skip step when element doesn't exist", function() {
      this.tour = new Tour();
      this.tour.addStep({
        element: "#tour-test"
      });
      this.tour.addStep({
        element: $("<div>").appendTo("#container")
      });
      this.tour.showStep(1);
      return assert.strictEqual(this.tour.getStep(1).element.data("popover").tip().filter(":visible").length, 1, "tour skips step with no element");
    });
    it("'showStep' should skip step when element is invisible", function() {
      this.tour = new Tour();
      this.tour.addStep({
        element: $("<div>").appendTo("#container").hide()
      });
      this.tour.addStep({
        element: $("<div>").appendTo("#container")
      });
      this.tour.showStep(1);
      return assert.strictEqual(this.tour.getStep(1).element.data("popover").tip().filter(":visible").length, 1, "tour skips step with no element");
    });
    it("'setCurrentStep' should set the current step", function() {
      this.tour = new Tour();
      this.tour.setCurrentStep(4);
      assert.strictEqual(this.tour._current, 4, "tour sets current step if passed a value");
      this.tour.setState("current_step", 2);
      this.tour.setCurrentStep();
      return assert.strictEqual(this.tour._current, 2, "tour reads current step state if not passed a value");
    });
    it("'showNextStep' should show the next step", function() {
      this.tour = new Tour();
      this.tour.addStep({
        element: $("<div>").appendTo("#container")
      });
      this.tour.addStep({
        element: $("<div>").appendTo("#container")
      });
      this.tour.start();
      this.tour.showNextStep();
      return assert.strictEqual(this.tour.getStep(1).element.data("popover").tip().filter(":visible").length, 1, "tour shows next step");
    });
    it("'showPrevStep' should show the previous step", function() {
      this.tour = new Tour();
      this.tour.addStep({
        element: $("<div>").appendTo("#container")
      });
      this.tour.addStep({
        element: $("<div>").appendTo("#container")
      });
      this.tour.showStep(1);
      this.tour.showPrevStep();
      return assert.strictEqual(this.tour.getStep(0).element.data("popover").tip().filter(":visible").length, 1, "tour shows previous step");
    });
    it("'showStep' should show multiple step on the same element", function() {
      var element;
      element = $("<div>").appendTo("#container");
      this.tour = new Tour();
      this.tour.addStep({
        element: element
      });
      this.tour.addStep({
        element: element
      });
      this.tour.start();
      assert.strictEqual(this.tour.getStep(0).element.data("popover").tip().filter(":visible").length, 1, "tour show the first step");
      this.tour.showNextStep();
      return assert.strictEqual(this.tour.getStep(1).element.data("popover").tip().filter(":visible").length, 1, "tour show the second step on the same element");
    });
    it("should properly verify paths", function() {
      this.tour = new Tour();
      assert.strictEqual(this.tour._isRedirect(void 0, "/"), false, "don't redirect if no path");
      assert.strictEqual(this.tour._isRedirect("", "/"), false, "don't redirect if path empty");
      assert.strictEqual(this.tour._isRedirect("/somepath", "/somepath"), false, "don't redirect if path matches current path");
      assert.strictEqual(this.tour._isRedirect("/somepath/", "/somepath"), false, "don't redirect if path with slash matches current path");
      assert.strictEqual(this.tour._isRedirect("/somepath", "/somepath/"), false, "don't redirect if path matches current path with slash");
      assert.strictEqual(this.tour._isRedirect("/somepath?search=true", "/somepath"), false, "don't redirect if path with query params matches current path");
      assert.strictEqual(this.tour._isRedirect("/somepath/?search=true", "/somepath"), false, "don't redirect if path with slash and query params matches current path");
      return assert.strictEqual(this.tour._isRedirect("/anotherpath", "/somepath"), true, "redirect if path doesn't match current path");
    });
    it("'getState' should return null after Tour.removeState with null value using cookies", function() {
      this.tour = new Tour({
        useLocalStorage: false
      });
      this.tour.setState("test", "test");
      this.tour.removeState("test");
      return assert.strictEqual(this.tour.getState("test"), null, "tour returns null after null setState");
    });
    it("'getState' should return null after Tour.removeState with null value using localStorage", function() {
      this.tour = new Tour({
        useLocalStorage: true
      });
      this.tour.setState("test", "test");
      this.tour.removeState("test");
      return assert.strictEqual(this.tour.getState("test"), null, "tour returns null after null setState");
    });
    it("'removeState' should call afterRemoveState callback", function() {
      var sentinel;
      sentinel = false;
      this.tour = new Tour({
        afterRemoveState: function() {
          return sentinel = true;
        }
      });
      this.tour.removeState("current_step");
      return assert.strictEqual(sentinel, true, "removeState calls callback");
    });
    it("shouldn't move to the next state until the onShow promise is resolved", function() {
      var deferred;
      this.tour = new Tour();
      deferred = $.Deferred();
      this.tour.addStep({
        element: $("<div>").appendTo("#container")
      });
      this.tour.addStep({
        element: $("<div>").appendTo("#container"),
        onShow: function() {
          return deferred;
        }
      });
      this.tour.start();
      this.tour.next();
      assert.strictEqual(this.tour._current, 0, "tour shows old state until resolving of onShow promise");
      deferred.resolve();
      return assert.strictEqual(this.tour._current, 1, "tour shows new state after resolving onShow promise");
    });
    it("shouldn't hide popover until the onHide promise is resolved", function() {
      var deferred;
      this.tour = new Tour();
      deferred = $.Deferred();
      this.tour.addStep({
        element: $("<div>").appendTo("#container"),
        onHide: function() {
          return deferred;
        }
      });
      this.tour.addStep({
        element: $("<div>").appendTo("#container")
      });
      this.tour.start();
      this.tour.next();
      assert.strictEqual(this.tour._current, 0, "tour shows old state until resolving of onHide promise");
      deferred.resolve();
      return assert.strictEqual(this.tour._current, 1, "tour shows new state after resolving onShow promise");
    });
    it("shouldn't start until the onStart promise is resolved", function() {
      var deferred;
      deferred = $.Deferred();
      this.tour = new Tour({
        onStart: function() {
          return deferred;
        }
      });
      this.tour.addStep({
        element: $("<div>").appendTo("#container")
      });
      this.tour.start();
      assert.strictEqual($(".popover").length, 0, " does not start before onStart promise is resolved");
      deferred.resolve();
      return assert.strictEqual($(".popover").length, 1, " starts after onStart promise is resolved");
    });
    it("'reflex' parameter should change the element cursor to pointer when the step is displayed", function() {
      var $element;
      $element = $("<div>").appendTo("#container");
      this.tour = new Tour();
      this.tour.addStep({
        element: $element,
        reflex: true
      });
      this.tour.addStep({
        element: $("<div>").appendTo("#container")
      });
      assert.strictEqual($element.css("cursor"), "auto", " doesn't change the element cursor before displaying the step");
      this.tour.start();
      assert.strictEqual($element.css("cursor"), "pointer", " change the element cursor to pointer when the step is displayed");
      this.tour.next();
      return assert.strictEqual($element.css("cursor"), "auto", " reset the element cursor when the step is hidden");
    });
    it("'reflex' parameter should change the element cursor to pointer when the step is displayed", function() {
      var $element;
      $element = $("<div>").appendTo("#container");
      this.tour = new Tour();
      this.tour.addStep({
        element: $element,
        reflex: true
      });
      this.tour.addStep({
        element: $("<div>").appendTo("#container")
      });
      assert.strictEqual($element.css("cursor"), "auto", " doesn't change the element cursor before displaying the step");
      this.tour.start();
      assert.strictEqual($element.css("cursor"), "pointer", " change the element cursor to pointer when the step is displayed");
      this.tour.next();
      return assert.strictEqual($element.css("cursor"), "auto", " reset the element cursor when the step is hidden");
    });
    it("'showStep' redirects to the anchor when the path is an anchor", function() {
      this.tour = new Tour();
      this.tour.addStep({
        element: $("<div>").appendTo("#container"),
        path: "#mytest"
      });
      this.tour.showStep(0);
      assert.strictEqual("#mytest", document.location.hash, " step has moved to the anchor");
      return document.location.hash = "";
    });
    it("'backdrop' parameter should show backdrop with step", function() {
      this.tour = new Tour();
      this.tour.addStep({
        element: $("<div>").appendTo("#container"),
        backdrop: false
      });
      this.tour.addStep({
        element: $("<div>").appendTo("#container"),
        backdrop: true
      });
      this.tour.showStep(0);
      assert.strictEqual($(".tour-backdrop").length, 0, "disable backdrop");
      assert.strictEqual($(".tour-step-backdrop").length, 0, "disable backdrop");
      assert.strictEqual($(".tour-step-background").length, 0, "disable backdrop");
      this.tour.showStep(1);
      assert.strictEqual($(".tour-backdrop").length, 1, "enable backdrop");
      assert.strictEqual($(".tour-step-backdrop").length, 1, "enable backdrop");
      assert.strictEqual($(".tour-step-background").length, 1, "enable backdrop");
      this.tour.end();
      assert.strictEqual($(".tour-backdrop").length, 0, "disable backdrop");
      assert.strictEqual($(".tour-step-backdrop").length, 0, "disable backdrop");
      return assert.strictEqual($(".tour-step-background").length, 0, "disable backdrop");
    });
    it("'basePath' should prepend the path to the steps", function() {
      this.tour = new Tour({
        basePath: 'test/'
      });
      this.tour.addStep({
        element: $("<div>").appendTo("#container"),
        path: 'test.html'
      });
      return assert.strictEqual(this.tour._isRedirect(this.tour._options.basePath + this.tour.getStep(0).path, 'test/test.html'), false, " adds basePath to step path");
    });
    it("with onNext option should run the callback before showing the next step", function() {
      var tour_test;
      tour_test = 0;
      this.tour = new Tour({
        onNext: function() {
          return tour_test += 2;
        }
      });
      this.tour.addStep({
        element: $("<div>").appendTo("#container")
      });
      this.tour.addStep({
        element: $("<div>").appendTo("#container")
      });
      this.tour.start();
      this.tour.next();
      return assert.strictEqual(tour_test, 2, "tour runs onNext when next step is called");
    });
    it("'addStep' with onNext option should run the callback before showing the next step", function() {
      var tour_test;
      tour_test = 0;
      this.tour = new Tour();
      this.tour.addStep({
        element: $("<div>").appendTo("#container"),
        onNext: function() {
          return tour_test = 2;
        }
      });
      this.tour.addStep({
        element: $("<div>").appendTo("#container")
      });
      this.tour.start();
      assert.strictEqual(tour_test, 0, "tour does not run onNext when next step is not called");
      this.tour.next();
      return assert.strictEqual(tour_test, 2, "tour runs onNext when next step is called");
    });
    it("with onPrev option should run the callback before showing the prev step", function() {
      var tour_test;
      tour_test = 0;
      this.tour = new Tour({
        onPrev: function() {
          return tour_test += 2;
        }
      });
      this.tour.addStep({
        element: $("<div>").appendTo("#container")
      });
      this.tour.addStep({
        element: $("<div>").appendTo("#container")
      });
      this.tour.start();
      this.tour.next();
      this.tour.prev();
      return assert.strictEqual(tour_test, 2, "tour runs onPrev when prev step is called");
    });
    return it("'addStep' with onPrev option should run the callback before showing the prev step", function() {
      var tour_test;
      tour_test = 0;
      this.tour = new Tour();
      this.tour.addStep({
        element: $("<div>").appendTo("#container")
      });
      this.tour.addStep({
        element: $("<div>").appendTo("#container"),
        onPrev: function() {
          return tour_test = 2;
        }
      });
      this.tour.start();
      assert.strictEqual(tour_test, 0, "tour does not run onPrev when prev step is not called");
      this.tour.next();
      this.tour.prev();
      return assert.strictEqual(tour_test, 2, "tour runs onPrev when prev step is called");
    });
  });

}).call(this);
